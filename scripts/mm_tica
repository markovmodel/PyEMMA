#!/usr/bin/env python

__version__ = '2013-01-28 jan'
__author__ = 'Fabian Paul'
__author_email__ = 'fabian.paul@mpikg.mpg.de'

import sys
import os
import inspect
import numpy
import math
import argparse

# import cocovar.so form the directory where this file resides
sys.path.append(os.path.realpath(os.path.dirname(inspect.getfile(inspect.currentframe())) + os.sep + '..'))
import cocovar

def correlation(cov, var):
    '''Calculate covariance matrix from correlation matrix.'''
    
    n = cov.shape[0]
    corr = numpy.zeros([n, n])
    for i in xrange(n):
        for j in xrange(n):
            corr[i, j] = cov[i, j] / math.sqrt(var[i] * var[j])
    return corr

def log_loop(iterable):
    '''Loop over iterable and display counter on stdout.'''
  
    for i, x in enumerate(iterable):
        sys.stdout.write('%05d\r' % i)
        sys.stdout.flush()
        yield x

def rename(fname, directory, inset=None):
    '''Change directory and extension of file name. 
    New extension is inset+original extension.'''

    res = directory + os.sep + os.path.basename(fname)
    if inset:
        name, orig_ext = os.path.splitext(res)
        res = name + inset + orig_ext
    return res

class Amuse:

    @classmethod
    def fromfiles(cls, mean, pca_weights, tica_weights, time_column=False):
        '''Initialize from files.'''

        amuse = cls(time_column)
        amuse.mean = numpy.genfromtxt(mean)
        error = Exception('Number of dimensions in mean and matrix does not agree.')
        if pca_weights:
            amuse.pca_weights = numpy.genfromtxt(pca_weights)
            if not amuse.pca_weights.shape[0] == amuse.pca_weights.shape[1] == amuse.mean.shape[0]:
                raise error
        if tica_weights:
            amuse.tica_weights = numpy.genfromtxt(tica_weights)
            if not amuse.tica_weights.shape[0] == amuse.tica_weights.shape[1] == amuse.mean.shape[0]:
                raise error
        amuse.n = amuse.mean.shape[0]
        return amuse
    
    @classmethod  
    def compute(cls, files, lag, normalize=False, time_column=False, mean=None):
        amuse = cls(time_column)
        if not files:
            raise Exception('No input trajectories were given.')

        # calculate mean
        if mean == None:
            print 'computing mean'
            mean_stats = {}
            for f in log_loop(files):
                cocovar.run(f, mean_stats, True, False, False, False, 0)
            amuse.mean = mean_stats['mean'] / mean_stats['samples']
        else:
            # use mean specified by the user
            if amuse.time_column:
                amuse.mean = numpy.hstack((numpy.zeros(1), mean))
            else:
                amuse.mean = mean

        # calculate rest of statistics
        print 'computing covariances'
        stats = { 'mean': amuse.mean }
        for f in log_loop(files):
            cocovar.run(f, stats, False, False, True, True, lag)
        
        amuse.n = stats['cov'].shape[0]
 
        cov = numpy.array(stats['cov'] / stats['samples'], dtype=float)
        tcov = numpy.array(stats['tcov'] / stats['tcov_samples'], dtype=float)
      
        amuse.var = cov.diagonal()
  
        if normalize:
            corr = correlation(cov, amuse.var)
            tcorr = correlation(tcov, amuse.var)
        else:
            corr = cov
            tcorr = tcov
    
        # symmetrization
        tcorr = 0.5 * (tcorr + numpy.transpose(tcorr))
             
        # remove time column
        if amuse.time_column:
            corr = corr[1:, 1:]
            tcorr = tcorr[1:, 1:]
            amuse.var = amuse.var[1:]
            amuse.mean = amuse.mean[1:]
            amuse.n = amuse.n - 1
    
        amuse.pca_values, amuse.pca_weights = numpy.linalg.eig(corr)
        # normalize weights by dividing by the standard deviation of the pcs 
        for i, l in enumerate(amuse.pca_values):
            amuse.pca_weights[:, i] = amuse.pca_weights[:, i] / math.sqrt(l)

        pc_tcorr = numpy.dot(numpy.dot(numpy.transpose(amuse.pca_weights), tcorr), amuse.pca_weights)
        amuse.tica_values, amuse.intermediate_weights = numpy.linalg.eig(pc_tcorr)
        amuse.tica_weights = numpy.dot(amuse.pca_weights, amuse.intermediate_weights)

        # sort eigenvalues und eigenvectors
        sort_perm = amuse.pca_values.argsort()[::-1]
        amuse.pca_values = amuse.pca_values[sort_perm]
        amuse.pca_weights = amuse.pca_weights[:, sort_perm]

        sort_perm = amuse.tica_values.argsort()[::-1]
        amuse.tica_values = amuse.tica_values[sort_perm]
        amuse.tica_weights = amuse.tica_weights[:, sort_perm]
    
        # if the transformation involves scaling of the original coordinates
        # using standard deviation, include this transformation in the matrices
        if normalize:
            std = numpy.sqrt(amuse.var)
            amuse.tica_weights = numpy.transpose(numpy.transpose(amuse.tica_weights) / std)
            amuse.pca_weights = numpy.transpose(numpy.transpose(amuse.pca_weights) / std)
            
        amuse.corr = corr
        amuse.tcorr = tcorr

        return amuse

    def __init__(self, time_column):
        self.time_column = time_column
    
    def pca(self, fin, fout, keep_pc):
        '''Perform PCA on data'''
        self.stream(fin, fout, self.pca_weights, keep_pc)

    def tica(self, fin, fout, keep_ic):
        '''Perform TICA on data'''
        self.stream(fin, fout, self.tica_weights, keep_ic)
    
    def stream(self, fin, fout, weights, keep_n=None):
        if fin == fout:
            raise Exception('Input file name is equal to output file name.')
        if not keep_n:
            keep_n = self.n  # keep all
        cocovar.stream(fin, fout, self.mean, weights, keep_n, self.time_column)

if __name__ == '__main__':

    myname = os.path.basename(inspect.getfile(inspect.currentframe()))

    if myname == 'mm_tica':
        parser = argparse.ArgumentParser(description='Calculate covariance matrices and weight matrices for PCA and TICA.')

    parser.add_argument('-i', '--trajectories', required=True, nargs='+', help='(input) trajectories', metavar='files')
    parser.add_argument('-T', '--timecolumn', default=False, help='ascii files contain time column?', action='store_true')	  
    parser.add_argument('-n', '--normalize', default=False, help='use correlation matrices instead of covariance matrices', action='store_true')
    parser.add_argument('-l', '--lagtime', default=None, help='lag time parameter tau for TICA (in frames)', metavar='frames', type=int)
    parser.add_argument('-c', '--covariancematrix', default=None, help='(output) file name for covariance matrix', metavar='file')
    parser.add_argument('-t', '--laggedcovariancematrix', default=None, help='(output) file name for symmetric, time-lagged covariance matrix', metavar='file')
    parser.add_argument('-C', '--covariances', default=None, help='(output) file name for PC eigenvalues (PC variances)', metavar='file')
    parser.add_argument('-S', '--timescales', default=None, help='(output) file name for IC eigenvalues (lagged IC variances)', metavar='file')
    parser.add_argument('-W', '--pcaweights', default=None, help='(output) file name for scaled PCA eigenvectors WSigma^-1', metavar='file')
    parser.add_argument('-V', '--ticaweights', default=None, help='(output) file name for TICA eigenvectors WSigma^-1V', metavar='file')
    parser.add_argument('-m', '--mean', default=None, help='(output) file name for data mean', metavar='file')
    parser.add_argument('-v', '--var', default=None, help='(output) file name for data variance', metavar='file')
    parser.add_argument('-M', '--usemean', default=None, help='(input) expert option: file name for mean', metavar='file', type=file)
    
    args = parser.parse_args()  

    # --lagtime is only required for tica, handle this
    if not args.lagtime:
        if args.ticaweights or args.laggedcovariancematrix or args.timescales:
            raise Exception('Muse select a value for --lagtime, if --ticaweights/--laggedcovariancematrix/--timescales is wanted.')
        else:
            lagtime = 1
    else:
        lagtime = args.lagtime
    
    if(args.usemean): 
        mean = numpy.genfromtxt(args.usemean)
    else:
        mean = None
    
    amuse = Amuse.compute(args.trajectories, lagtime, args.normalize, args.timecolumn, mean)
    
    if(args.covariances): numpy.savetxt(args.covariances, amuse.pca_values)
    if(args.timescales): numpy.savetxt(args.timescales, amuse.tica_values)
    if(args.pcaweights): numpy.savetxt(args.pcaweights, amuse.pca_weights)
    if(args.ticaweights): numpy.savetxt(args.ticaweights, amuse.tica_weights)
    if(args.mean): numpy.savetxt(args.mean, amuse.mean)
    if(args.var): numpy.savetxt(args.var, amuse.var)
    if(args.covariancematrix): numpy.savetxt(args.covariancematrix, amuse.corr)
    if(args.laggedcovariancematrix): numpy.savetxt(args.laggedcovariancematrix, amuse.tcorr)

    elif myname == 'mm_project':
        parser = argparse.ArgumentParser(description='Subtract mean and project using a matrix.')

    parser.add_argument('-i', '--trajectories', required=True, nargs='+', help='(input) trajectories', metavar='files')
    parser.add_argument('-T', '--timecolumn', default=False, help='ascii files contain time column?', action='store_true')
    parser.add_argument('-p', '--outdir', required=True, help='(output) directory for order parameter trajectories', metavar='dir')
    parser.add_argument('-W', '--weights', required=True, help='(input) file name for transformation matrix', type=file)
    parser.add_argument('-m', '--mean', required=True, help='(input) file name for data mean', type=file)
    parser.add_argument('-k', '--keepnp', default=None, help='number of dominant order parameters to keep (default=keep all)', metavar='N', type=int)
    parser.add_argument('-d', '--descriptor', default=None, help='string to insert between the file name and the extension of order parameter trajectories', metavar='string')
  
    args = parser.parse_args()  
    
    amuse = Amuse.fromfiles(args.mean, None, args.weights, args.timecolumn)
    
    for t in log_loop(args.trajectories):
        amuse.stream(t, rename(t, args.outdir, args.descriptor), amuse.tica_weights, args.keepnp)
